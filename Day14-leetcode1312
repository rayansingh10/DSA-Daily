https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/

class Solution {
public:
    int rec(string& s,int start,int end){
        if(start>=end) return 0;
        if(s[start]!=s[end]){
            //front insert
            int front=1+rec(s,start,end-1);
            int last=1+rec(s,start+1,end);
            return min(front,last);
        }
        return rec(s,start+1,end-1);
    }
    int memo(string& s,int start,int end,vector<vector<int>> &dp){
        if(start>=end) return 0;
        if(dp[start][end]!=-1) return dp[start][end];
        if(s[start]!=s[end]){
            //front insert
            int front=1+memo(s,start,end-1,dp);
            int last=1+memo(s,start+1,end,dp);
            return dp[start][end]=min(front,last);
        }
        return dp[start][end]=memo(s,start+1,end-1,dp);
    }
    int bottum(string& s){
        vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1,0));
        for(int start=s.size()-1;start>=0;start--){
            for(int end=0;end<s.size();end++){
                if(start>=end) continue;
                if(s[start]!=s[end]){
                    //front insert
                    int front=1+dp[start][end-1];
                    int last=1+dp[start+1][end];
                    dp[start][end]=min(front,last);
                }
                else dp[start][end]=dp[start+1][end-1];
            }
        }
        return dp[0][s.size()-1];
    }
    int minInsertions(string s) {
        return bottum(s);
        /* vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1,-1));
        return memo(s,0,s.size()-1,dp); */
       //return rec(s,0,s.size()-1);
    }
};
